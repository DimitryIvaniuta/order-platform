spring:
  application:
    name: api-gateway

  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:8080/api
          # Boot will call /.well-known/openid-configuration on this issuer
          # issuer-uri: ${SECURITY_ISSUER_URI:http://localhost:8080}
          # Use JWKS directly (avoid discovery races). Keep only ONE of these.
#          jwk-set-uri: ${JWT_JWKS_URI:http://localhost:8080/api/.well-known/jwks.json}
  r2dbc:
    url: r2dbc:postgresql://${DB_HOST:localhost}:${DB_PORT_GATEWAY:5437}/${DB_NAME_GATEWAY:gateway}
    username: ${DB_USER:user}
    password: ${DB_PASS:pass}
    pool:
      enabled: true
      initial-size: 10
      max-size: 50
      max-idle-time: 30s
      validation-query: SELECT 1
      max-acquire-time: 5s
      max-create-connection-time: 5s
      max-life-time: 30m

  flyway:
    enabled: true
    url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT_GATEWAY:5437}/${DB_NAME_GATEWAY:gateway}
    user: ${DB_USER:user}
    password: ${DB_PASS:pass}
    locations: classpath:db/migration

  webflux:
    base-path: /api

  cloud:
    gateway:
      server:
        webflux:
          routes:
            - id: order-service
              uri: http://localhost:8081   # <-- make sure this is your order-service port
              predicates:
                - Path=/orders/**
              filters:
                - PreserveHostHeader       # NO StripPrefix

server:
  port: ${GATEWAY_PORT:8080}

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus,gateway
  endpoint:
    gateway:
      # choose one:
      access: read-only     # GET/HEAD only (see routes etc.)
      # access: unrestricted  # allows write ops like POST /actuator/gateway/refresh
    health:
      show-details: always

springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui.html

security:
  jwt:
    # When running in Docker Compose, set SECURITY_ISSUER_URI=http://api-gateway:8080
    issuer: http://localhost:8080/api
    audience: order-service
    access-token-ttl: PT10M
    key-rotation-interval: PT24H
    key-retention: PT48H
    jwks-uri: ${JWT_JWKS_URI:http://localhost:8080/api/.well-known/jwks.json}
  authz:
    tenant-claim: mt
    keycloak-tenant-resource-prefix: "tenant:"
    scope-authority-prefix: SCOPE_
    tenant-role-authority-pattern: TENANT_%s:%s
    map-audience-to-authorities: false
    audience-authority-prefix: AUD_
    tenant-header: X-Tenant-ID

kafka:
  bootstrap-servers: ${KAFKA_BOOTSTRAP:localhost:9092}
  client-id: ${spring.application.name}
  group-id: ${spring.application.name}-consumer
  topics:
    commands:
      orderCreate: order.command.create.v1
    events:
      order:     order.events.v1
      payment:   payment.events.v1
      inventory: inventory.events.v1

resilience4j:
  circuitbreaker:
    configs:
      default:
        slidingWindowType: COUNT_BASED
        slidingWindowSize: 50
        failureRateThreshold: 50
        slowCallRateThreshold: 50
        slowCallDurationThreshold: 2s
        minimumNumberOfCalls: 20
        waitDurationInOpenState: 10s
        permittedNumberOfCallsInHalfOpenState: 5
        registerHealthIndicator: true
    instances:
      orderSvc:
        baseConfig: default

  timelimiter:
    configs:
      default:
        timeoutDuration: 3s
    instances:
      orderSvc:
        baseConfig: default

logging:
  level:
    org.springframework.cloud.gateway: DEBUG
    reactor.netty.http.client: DEBUG